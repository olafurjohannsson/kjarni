/*
 * Kjarni FFI - C bindings for Kjarni ML library
 * Auto-generated by cbindgen. Do not edit manually.
 */


#ifndef KJARNI_FFI_H
#define KJARNI_FFI_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

/**
 * Error codes returned by Kjarni FFI functions.
 */
typedef enum KjarniKjarniErrorCode {
    /**
     * Operation completed successfully
     */
    KJARNI_KJARNI_ERROR_CODE_OK = 0,
    /**
     * Null pointer passed to function
     */
    KJARNI_KJARNI_ERROR_CODE_NULL_POINTER = 1,
    /**
     * Invalid UTF-8 string
     */
    KJARNI_KJARNI_ERROR_CODE_INVALID_UTF8 = 2,
    /**
     * Model not found in registry
     */
    KJARNI_KJARNI_ERROR_CODE_MODEL_NOT_FOUND = 3,
    /**
     * Failed to load model
     */
    KJARNI_KJARNI_ERROR_CODE_LOAD_FAILED = 4,
    /**
     * Inference operation failed
     */
    KJARNI_KJARNI_ERROR_CODE_INFERENCE_FAILED = 5,
    /**
     * GPU not available
     */
    KJARNI_KJARNI_ERROR_CODE_GPU_UNAVAILABLE = 6,
    /**
     * Invalid configuration
     */
    KJARNI_KJARNI_ERROR_CODE_INVALID_CONFIG = 7,
    /**
     * Operation was cancelled
     */
    KJARNI_KJARNI_ERROR_CODE_CANCELLED = 8,
    /**
     * Operation timed out
     */
    KJARNI_KJARNI_ERROR_CODE_TIMEOUT = 9,
    /**
     * Stream has ended
     */
    KJARNI_KJARNI_ERROR_CODE_STREAM_ENDED = 10,
    /**
     * Unknown error
     */
    KJARNI_KJARNI_ERROR_CODE_UNKNOWN = 255,
} KjarniKjarniErrorCode;

/**
 * Device selection for inference.
 */
typedef enum KjarniKjarniDevice {
    /**
     * Use CPU for inference
     */
    KJARNI_KJARNI_DEVICE_CPU = 0,
    /**
     * Use GPU for inference
     */
    KJARNI_KJARNI_DEVICE_GPU = 1,
} KjarniKjarniDevice;

/**
 * Progress stage enum for FFI
 */
typedef enum KjarniKjarniProgressStage {
    KJARNI_KJARNI_PROGRESS_STAGE_SCANNING = 0,
    KJARNI_KJARNI_PROGRESS_STAGE_LOADING = 1,
    KJARNI_KJARNI_PROGRESS_STAGE_EMBEDDING = 2,
    KJARNI_KJARNI_PROGRESS_STAGE_WRITING = 3,
    KJARNI_KJARNI_PROGRESS_STAGE_COMMITTING = 4,
    KJARNI_KJARNI_PROGRESS_STAGE_SEARCHING = 5,
    KJARNI_KJARNI_PROGRESS_STAGE_RERANKING = 6,
} KjarniKjarniProgressStage;

/**
 * Search mode enum for FFI.
 *
 * Determines how the search query is processed:
 * - Keyword (0): BM25 text matching only
 * - Semantic (1): Vector similarity only
 * - Hybrid (2): Combined approach (recommended)
 */
typedef enum KjarniKjarniSearchMode {
    /**
     * BM25 keyword search
     */
    KJARNI_KJARNI_SEARCH_MODE_KEYWORD = 0,
    /**
     * Embedding-based semantic search
     */
    KJARNI_KJARNI_SEARCH_MODE_SEMANTIC = 1,
    /**
     * Combined keyword + semantic (default, recommended)
     */
    KJARNI_KJARNI_SEARCH_MODE_HYBRID = 2,
} KjarniKjarniSearchMode;

/**
 * Cancellation token
 */
typedef struct KjarniKjarniCancelToken KjarniKjarniCancelToken;

/**
 * Opaque handle to a Classifier.
 */
typedef struct KjarniKjarniClassifier KjarniKjarniClassifier;

/**
 * Opaque handle to an Embedder instance.
 */
typedef struct KjarniKjarniEmbedder KjarniKjarniEmbedder;

/**
 * Opaque handle to an Indexer instance.
 *
 * Created via `kjarni_indexer_new`, must be freed via `kjarni_indexer_free`.
 */
typedef struct KjarniKjarniIndexer KjarniKjarniIndexer;

/**
 * Opaque handle to a Reranker
 */
typedef struct KjarniKjarniReranker KjarniKjarniReranker;

/**
 * Opaque handle to a Searcher instance.
 *
 * Created via `kjarni_searcher_new`, must be freed via `kjarni_searcher_free`.
 */
typedef struct KjarniKjarniSearcher KjarniKjarniSearcher;

/**
 * Float array returned by FFI functions. Caller must free with kjarni_float_array_free.
 */
typedef struct KjarniKjarniFloatArray {
    float *data;
    uintptr_t len;
} KjarniKjarniFloatArray;

/**
 * 2D float array for batch results. Caller must free with kjarni_float_2d_array_free.
 */
typedef struct KjarniKjarniFloat2DArray {
    float *data;
    uintptr_t rows;
    uintptr_t cols;
} KjarniKjarniFloat2DArray;

/**
 * String array. Caller must free with kjarni_string_array_free.
 */
typedef struct KjarniKjarniStringArray {
    char **strings;
    uintptr_t len;
} KjarniKjarniStringArray;

/**
 * Configuration for creating an Embedder.
 */
typedef struct KjarniKjarniEmbedderConfig {
    /**
     * Device to use (CPU or GPU)
     */
    enum KjarniKjarniDevice device;
    /**
     * Cache directory for models (NULL = default)
     */
    const char *cache_dir;
    /**
     * Model name from registry (NULL = "minilm-l6-v2")
     */
    const char *model_name;
    /**
     * Path to local model (NULL = use registry)
     */
    const char *model_path;
    /**
     * Whether to L2-normalize embeddings (1 = yes, 0 = no)
     */
    int32_t normalize;
    /**
     * Suppress progress output (1 = quiet, 0 = verbose)
     */
    int32_t quiet;
} KjarniKjarniEmbedderConfig;

/**
 * Single classification result (label + score).
 */
typedef struct KjarniKjarniClassResult {
    /**
     * Label name (must be freed with kjarni_string_free)
     */
    char *label;
    /**
     * Confidence score
     */
    float score;
} KjarniKjarniClassResult;

/**
 * Array of classification results.
 */
typedef struct KjarniKjarniClassResults {
    /**
     * Array of results
     */
    struct KjarniKjarniClassResult *results;
    /**
     * Number of results
     */
    uintptr_t len;
} KjarniKjarniClassResults;

/**
 * Configuration for creating a Classifier.
 */
typedef struct KjarniKjarniClassifierConfig {
    /**
     * Device to use
     */
    enum KjarniKjarniDevice device;
    /**
     * Cache directory (NULL = default)
     */
    const char *cache_dir;
    /**
     * Model name (NULL = default)
     */
    const char *model_name;
    /**
     * Model path (NULL = use registry)
     */
    const char *model_path;
    /**
     * Custom labels (NULL = use model labels)
     */
    const char *const *labels;
    /**
     * Number of custom labels
     */
    uintptr_t num_labels;
    /**
     * Multi-label mode (1 = multi-label, 0 = single-label)
     */
    int32_t multi_label;
    /**
     * Suppress output
     */
    int32_t quiet;
} KjarniKjarniClassifierConfig;

/**
 * Single rerank result
 */
typedef struct KjarniKjarniRerankResult {
    uintptr_t index;
    float score;
} KjarniKjarniRerankResult;

/**
 * Array of rerank results
 */
typedef struct KjarniKjarniRerankResults {
    struct KjarniKjarniRerankResult *results;
    uintptr_t len;
} KjarniKjarniRerankResults;

/**
 * Configuration for Reranker
 */
typedef struct KjarniKjarniRerankerConfig {
    enum KjarniKjarniDevice device;
    const char *cache_dir;
    const char *model_name;
    const char *model_path;
    int32_t quiet;
} KjarniKjarniRerankerConfig;

/**
 * Information about an existing index.
 *
 * Retrieved via `kjarni_index_info`. The caller must free this struct
 * using `kjarni_index_info_free` to avoid memory leaks.
 */
typedef struct KjarniKjarniIndexInfo {
    /**
     * Path to the index directory (must be freed)
     */
    char *path;
    /**
     * Total number of documents in the index
     */
    uintptr_t document_count;
    /**
     * Number of index segments
     */
    uintptr_t segment_count;
    /**
     * Embedding dimension
     */
    uintptr_t dimension;
    /**
     * Total size on disk in bytes
     */
    uint64_t size_bytes;
    /**
     * Embedding model name used to create the index (may be NULL, must be freed if not)
     */
    char *embedding_model;
} KjarniKjarniIndexInfo;

/**
 * Configuration for creating an Indexer.
 *
 * Use `kjarni_indexer_config_default()` to get sensible defaults,
 * then modify fields as needed before passing to `kjarni_indexer_new()`.
 */
typedef struct KjarniKjarniIndexerConfig {
    /**
     * Device to run embeddings on (CPU or GPU)
     */
    enum KjarniKjarniDevice device;
    /**
     * Directory to cache downloaded models (NULL = system default)
     */
    const char *cache_dir;
    /**
     * Embedding model name (NULL = "minilm-l6-v2")
     */
    const char *model_name;
    /**
     * Maximum chunk size in characters
     */
    uintptr_t chunk_size;
    /**
     * Overlap between adjacent chunks in characters
     */
    uintptr_t chunk_overlap;
    /**
     * Batch size for embedding operations
     */
    uintptr_t batch_size;
    /**
     * Comma-separated list of file extensions to include (NULL = use defaults)
     */
    const char *extensions;
    /**
     * Comma-separated list of glob patterns to exclude
     */
    const char *exclude_patterns;
    /**
     * Whether to recurse into subdirectories (1 = true, 0 = false)
     */
    int32_t recursive;
    /**
     * Whether to include hidden files (1 = true, 0 = false)
     */
    int32_t include_hidden;
    /**
     * Maximum file size in bytes (0 = no limit)
     */
    uintptr_t max_file_size;
    /**
     * Suppress progress output to stderr (1 = quiet, 0 = verbose)
     */
    int32_t quiet;
} KjarniKjarniIndexerConfig;

/**
 * Statistics returned after indexing operations.
 *
 * This struct is returned by `kjarni_indexer_create` and contains
 * information about what was indexed and how long it took.
 */
typedef struct KjarniKjarniIndexStats {
    /**
     * Number of document chunks indexed (after splitting)
     */
    uintptr_t documents_indexed;
    /**
     * Number of chunks created from source files
     */
    uintptr_t chunks_created;
    /**
     * Embedding dimension used
     */
    uintptr_t dimension;
    /**
     * Total index size on disk in bytes
     */
    uint64_t size_bytes;
    /**
     * Number of source files successfully processed
     */
    uintptr_t files_processed;
    /**
     * Number of source files skipped (errors, unsupported format, too large)
     */
    uintptr_t files_skipped;
    /**
     * Total time taken in milliseconds
     */
    uint64_t elapsed_ms;
} KjarniKjarniIndexStats;

/**
 * Progress data passed to callbacks
 */
typedef struct KjarniKjarniProgress {
    enum KjarniKjarniProgressStage stage;
    uintptr_t current;
    uintptr_t total;
    const char *message;
} KjarniKjarniProgress;

/**
 * Generic callback function pointer type for progress
 */
typedef void (*KjarniKjarniProgressCallbackFn)( struct KjarniKjarniProgress progress, void *user_data );

/**
 * Single search result returned from a query.
 *
 * Contains the matched text, relevance score, and associated metadata.
 */
typedef struct KjarniKjarniSearchResult {
    /**
     * Relevance score (higher is better, scale depends on search mode)
     */
    float score;
    /**
     * Document ID within the index
     */
    uintptr_t document_id;
    /**
     * The matched text chunk (must be freed)
     */
    char *text;
    /**
     * JSON-encoded metadata (must be freed, may be NULL)
     */
    char *metadata_json;
} KjarniKjarniSearchResult;

/**
 * Array of search results.
 *
 * Must be freed with `kjarni_search_results_free` after use.
 */
typedef struct KjarniKjarniSearchResults {
    /**
     * Pointer to array of results
     */
    struct KjarniKjarniSearchResult *results;
    /**
     * Number of results
     */
    uintptr_t len;
} KjarniKjarniSearchResults;

/**
 * Search options for customizing query behavior.
 *
 * Use `kjarni_search_options_default()` to get defaults, then modify as needed.
 */
typedef struct KjarniKjarniSearchOptions {
    /**
     * Search mode (-1 = use searcher default)
     */
    int32_t mode;
    /**
     * Number of results to return (0 = use searcher default)
     */
    uintptr_t top_k;
    /**
     * Use reranker: -1 = auto (use if available), 0 = no, 1 = yes
     */
    int32_t use_reranker;
    /**
     * Minimum score threshold (0.0 = no threshold)
     */
    float threshold;
    /**
     * Filter by source file pattern, glob syntax (NULL = no filter)
     */
    const char *source_pattern;
    /**
     * Metadata key to filter on (NULL = no filter)
     */
    const char *filter_key;
    /**
     * Required value for filter_key (NULL = no filter)
     */
    const char *filter_value;
} KjarniKjarniSearchOptions;

/**
 * Configuration for creating a Searcher.
 *
 * Use `kjarni_searcher_config_default()` to get sensible defaults,
 * then modify fields as needed before passing to `kjarni_searcher_new()`.
 */
typedef struct KjarniKjarniSearcherConfig {
    /**
     * Device to run models on (CPU or GPU)
     */
    enum KjarniKjarniDevice device;
    /**
     * Directory to cache downloaded models (NULL = system default)
     */
    const char *cache_dir;
    /**
     * Embedding model name (NULL = "minilm-l6-v2")
     */
    const char *model_name;
    /**
     * Cross-encoder reranker model (NULL = no reranking)
     */
    const char *rerank_model;
    /**
     * Default search mode
     */
    enum KjarniKjarniSearchMode default_mode;
    /**
     * Default number of results
     */
    uintptr_t default_top_k;
    /**
     * Suppress progress output (1 = quiet, 0 = verbose)
     */
    int32_t quiet;
} KjarniKjarniSearcherConfig;

/**
 * Initialize the Kjarni runtime. Optional - auto-initialized on first use.
 */
kjarni_ enum KjarniKjarniErrorCode kjarni_init( void );

/**
 * Shutdown and cleanup. Call before process exit.
 */
kjarni_ void kjarni_shutdown( void );

/**
 * Get the library version string.
 */
kjarni_ const char *kjarni_version( void );

/**
 * Free a float array allocated by Kjarni.
 */
kjarni_ void kjarni_float_array_free( struct KjarniKjarniFloatArray arr );

/**
 * Free a 2D float array allocated by Kjarni.
 */
kjarni_ void kjarni_float_2d_array_free( struct KjarniKjarniFloat2DArray arr );

/**
 * Free a string allocated by Kjarni.
 */
kjarni_ void kjarni_string_free( char *s );

/**
 * Free a string array allocated by Kjarni.
 */
kjarni_ void kjarni_string_array_free( struct KjarniKjarniStringArray arr );

kjarni_ struct KjarniKjarniCancelToken *kjarni_cancel_token_new( void );

kjarni_ void kjarni_cancel_token_cancel( struct KjarniKjarniCancelToken *token );

kjarni_ bool kjarni_cancel_token_is_cancelled( const struct KjarniKjarniCancelToken *token );

kjarni_ void kjarni_cancel_token_reset( struct KjarniKjarniCancelToken *token );

kjarni_ void kjarni_cancel_token_free( struct KjarniKjarniCancelToken *token );

kjarni_ const char *kjarni_error_code_to_string( enum KjarniKjarniErrorCode err );

/**
 * Get the name of an error code as a C string.
 */
kjarni_ const char *kjarni_error_name( enum KjarniKjarniErrorCode err );

/**
 * Get the last error message. Returns NULL if no error.
 */
kjarni_ const char *kjarni_last_error_message( void );

/**
 * Clear the last error.
 */
kjarni_ void kjarni_clear_error( void );

/**
 * Get default embedder configuration.
 */
kjarni_ struct KjarniKjarniEmbedderConfig kjarni_embedder_config_default( void );

/**
 * Create a new Embedder.
 *
 * # Safety
 * - `config` must be valid or NULL (uses defaults)
 * - `out` must be a valid pointer
 * - The returned handle must be freed with `kjarni_embedder_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_embedder_new( const struct KjarniKjarniEmbedderConfig *config,
                                                struct KjarniKjarniEmbedder **out );

/**
 * Free an Embedder instance.
 *
 * # Safety
 * - `embedder` must be a valid handle or NULL
 * - The handle must not be used after this call
 */
kjarni_ void kjarni_embedder_free( struct KjarniKjarniEmbedder *embedder );

/**
 * Encode a single text to an embedding vector.
 *
 * # Safety
 * - `embedder` must be a valid handle
 * - `text` must be a valid null-terminated UTF-8 string
 * - `out` must be a valid pointer
 * - The returned array must be freed with `kjarni_float_array_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_embedder_encode( struct KjarniKjarniEmbedder *embedder,
                                                   const char *text,
                                                   struct KjarniKjarniFloatArray *out );

/**
 * Encode multiple texts to embedding vectors.
 *
 * # Safety
 * - `embedder` must be a valid handle
 * - `texts` must be an array of `num_texts` valid null-terminated UTF-8 strings
 * - `out` must be a valid pointer
 * - The returned array must be freed with `kjarni_float_2d_array_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_embedder_encode_batch( struct KjarniKjarniEmbedder *embedder,
                                                         const char *const *texts,
                                                         uintptr_t num_texts,
                                                         struct KjarniKjarniFloat2DArray *out );

/**
 * Compute cosine similarity between two texts.
 *
 * # Safety
 * - `embedder` must be a valid handle
 * - `text1` and `text2` must be valid null-terminated UTF-8 strings
 * - `out` must be a valid pointer
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_embedder_similarity( struct KjarniKjarniEmbedder *embedder,
                                                       const char *text1,
                                                       const char *text2,
                                                       float *out );

/**
 * Get the embedding dimension.
 *
 * # Safety
 * - `embedder` must be a valid handle
 */
kjarni_ uintptr_t kjarni_embedder_dim( const struct KjarniKjarniEmbedder *embedder );

/**
 * Free classification results.
 */
kjarni_ void kjarni_class_results_free( struct KjarniKjarniClassResults results );

/**
 * Get default classifier configuration.
 */
kjarni_ struct KjarniKjarniClassifierConfig kjarni_classifier_config_default( void );

/**
 * Create a new Classifier.
 *
 * # Safety
 * - `config` must be valid or NULL
 * - `out` must be a valid pointer
 * - The returned handle must be freed with `kjarni_classifier_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_classifier_new( const struct KjarniKjarniClassifierConfig *config,
                                                  struct KjarniKjarniClassifier **out );

/**
 * Free a Classifier.
 */
kjarni_ void kjarni_classifier_free( struct KjarniKjarniClassifier *classifier );

/**
 * Classify a single text.
 *
 * # Safety
 * - `classifier` must be valid
 * - `text` must be valid UTF-8
 * - `out` must be valid
 * - Results must be freed with `kjarni_class_results_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_classifier_classify( struct KjarniKjarniClassifier *classifier,
                                                       const char *text,
                                                       struct KjarniKjarniClassResults *out );

/**
 * Get the classifier's labels.
 *
 * # Safety
 * - `classifier` must be valid
 * - `out` must be valid
 * - Results must be freed with `kjarni_string_array_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_classifier_labels( const struct KjarniKjarniClassifier *classifier,
                                                     struct KjarniKjarniStringArray *out );

/**
 * Get number of labels.
 */
kjarni_ uintptr_t kjarni_classifier_num_labels( const struct KjarniKjarniClassifier *classifier );

/**
 * Free rerank results
 */
kjarni_ void kjarni_rerank_results_free( struct KjarniKjarniRerankResults results );

/**
 * Get default reranker configuration
 */
kjarni_ struct KjarniKjarniRerankerConfig kjarni_reranker_config_default( void );

/**
 * Create a new Reranker
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_reranker_new( const struct KjarniKjarniRerankerConfig *config,
                                                struct KjarniKjarniReranker **out );

/**
 * Free a Reranker
 */
kjarni_ void kjarni_reranker_free( struct KjarniKjarniReranker *reranker );

/**
 * Score a single query-document pair
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_reranker_score( struct KjarniKjarniReranker *reranker,
                                                  const char *query,
                                                  const char *document,
                                                  float *out );

/**
 * Rerank documents by relevance to query
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_reranker_rerank( struct KjarniKjarniReranker *reranker,
                                                   const char *query,
                                                   const char *const *documents,
                                                   uintptr_t num_docs,
                                                   struct KjarniKjarniRerankResults *out );

/**
 * Rerank and return top-k results
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_reranker_rerank_top_k( struct KjarniKjarniReranker *reranker,
                                                         const char *query,
                                                         const char *const *documents,
                                                         uintptr_t num_docs,
                                                         uintptr_t top_k,
                                                         struct KjarniKjarniRerankResults *out );

/**
 * Free memory allocated for index info strings.
 *
 * # Safety
 *
 * Must only be called once per `KjarniIndexInfo` returned from `kjarni_index_info`.
 */
kjarni_ void kjarni_index_info_free( struct KjarniKjarniIndexInfo info );

/**
 * Get default indexer configuration.
 *
 * Returns a configuration with sensible defaults:
 * - CPU device
 * - minilm-l6-v2 model
 * - 512 character chunks with 50 character overlap
 * - 32 batch size
 * - 10MB max file size
 * - Recursive directory traversal
 * - Hidden files excluded
 */
kjarni_ struct KjarniKjarniIndexerConfig kjarni_indexer_config_default( void );

/**
 * Create a new Indexer.
 *
 * # Arguments
 *
 * * `config` - Configuration options (NULL for defaults)
 * * `out` - Pointer to receive the created indexer handle
 *
 * # Returns
 *
 * `KjarniErrorCode::Ok` on success, error code otherwise.
 * On error, call `kjarni_last_error_message()` for details.
 *
 * # Safety
 *
 * - `out` must be a valid pointer
 * - The returned handle must be freed with `kjarni_indexer_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_indexer_new( const struct KjarniKjarniIndexerConfig *config,
                                               struct KjarniKjarniIndexer **out );

/**
 * Free an Indexer handle.
 *
 * # Safety
 *
 * - `indexer` must be a handle returned by `kjarni_indexer_new`
 * - Must not be called more than once per handle
 * - Handle must not be used after freeing
 */
kjarni_ void kjarni_indexer_free( struct KjarniKjarniIndexer *indexer );

/**
 * Create a new index from files/directories (simple version).
 *
 * This is the simple API without progress callbacks. For progress reporting
 * and cancellation support, use `kjarni_indexer_create_with_callback`.
 *
 * # Arguments
 *
 * * `indexer` - Indexer handle from `kjarni_indexer_new`
 * * `index_path` - Path where the index will be created
 * * `inputs` - Array of file/directory paths to index
 * * `num_inputs` - Number of elements in `inputs` array
 * * `force` - If non-zero, overwrite existing index at `index_path`
 * * `out` - Pointer to receive indexing statistics
 *
 * # Returns
 *
 * `KjarniErrorCode::Ok` on success, error code otherwise.
 *
 * # Safety
 *
 * - All pointers must be valid
 * - `inputs` must contain at least `num_inputs` valid C strings
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_indexer_create( struct KjarniKjarniIndexer *indexer,
                                                  const char *index_path,
                                                  const char *const *inputs,
                                                  uintptr_t num_inputs,
                                                  int32_t force,
                                                  struct KjarniKjarniIndexStats *out );

/**
 * Create a new index with progress callback and cancellation support.
 *
 * This is the full-featured API that supports:
 * - Progress reporting via callback
 * - Cancellation via cancel token
 *
 * # Arguments
 *
 * * `indexer` - Indexer handle from `kjarni_indexer_new`
 * * `index_path` - Path where the index will be created
 * * `inputs` - Array of file/directory paths to index
 * * `num_inputs` - Number of elements in `inputs` array
 * * `force` - If non-zero, overwrite existing index at `index_path`
 * * `progress_callback` - Optional callback for progress updates (may be NULL)
 * * `user_data` - Opaque pointer passed to callback (may be NULL)
 * * `cancel_token` - Optional cancellation token (may be NULL)
 * * `out` - Pointer to receive indexing statistics
 *
 * # Callback
 *
 * The progress callback receives a `KjarniProgress` struct with:
 * - `stage`: Current operation (scanning, loading, embedding, etc.)
 * - `current`: Current item number
 * - `total`: Total items (may be 0 if unknown)
 * - `message`: Optional status message (may be NULL)
 *
 * # Returns
 *
 * `KjarniErrorCode::Ok` on success, `KjarniErrorCode::Cancelled` if cancelled,
 * or other error code on failure.
 *
 * # Safety
 *
 * - All non-optional pointers must be valid
 * - `inputs` must contain at least `num_inputs` valid C strings
 * - Callback must be thread-safe if indexer uses multiple threads
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_indexer_create_with_callback( struct KjarniKjarniIndexer *indexer,
                                                                const char *index_path,
                                                                const char *const *inputs,
                                                                uintptr_t num_inputs,
                                                                int32_t force,
                                                                KjarniKjarniProgressCallbackFn progress_callback,
                                                                void *user_data,
                                                                const struct KjarniKjarniCancelToken *cancel_token,
                                                                struct KjarniKjarniIndexStats *out );

/**
 * Add documents to an existing index (simple version).
 *
 * This is the simple API without progress callbacks. For progress reporting
 * and cancellation support, use `kjarni_indexer_add_with_callback`.
 *
 * # Arguments
 *
 * * `indexer` - Indexer handle from `kjarni_indexer_new`
 * * `index_path` - Path to existing index
 * * `inputs` - Array of file/directory paths to add
 * * `num_inputs` - Number of elements in `inputs` array
 * * `documents_added` - Pointer to receive count of documents added
 *
 * # Returns
 *
 * `KjarniErrorCode::Ok` on success, error code otherwise.
 *
 * # Safety
 *
 * - All pointers must be valid
 * - `inputs` must contain at least `num_inputs` valid C strings
 * - Index at `index_path` must exist and be compatible (same embedding dimension)
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_indexer_add( struct KjarniKjarniIndexer *indexer,
                                               const char *index_path,
                                               const char *const *inputs,
                                               uintptr_t num_inputs,
                                               uintptr_t *documents_added );

/**
 * Add documents to an existing index with progress callback and cancellation support.
 *
 * This is the full-featured API that supports:
 * - Progress reporting via callback
 * - Cancellation via cancel token
 *
 * # Arguments
 *
 * * `indexer` - Indexer handle from `kjarni_indexer_new`
 * * `index_path` - Path to existing index
 * * `inputs` - Array of file/directory paths to add
 * * `num_inputs` - Number of elements in `inputs` array
 * * `progress_callback` - Optional callback for progress updates (may be NULL)
 * * `user_data` - Opaque pointer passed to callback (may be NULL)
 * * `cancel_token` - Optional cancellation token (may be NULL)
 * * `documents_added` - Pointer to receive count of documents added
 *
 * # Returns
 *
 * `KjarniErrorCode::Ok` on success, `KjarniErrorCode::Cancelled` if cancelled,
 * or other error code on failure.
 *
 * # Safety
 *
 * - All non-optional pointers must be valid
 * - `inputs` must contain at least `num_inputs` valid C strings
 * - Index at `index_path` must exist and be compatible
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_indexer_add_with_callback( struct KjarniKjarniIndexer *indexer,
                                                             const char *index_path,
                                                             const char *const *inputs,
                                                             uintptr_t num_inputs,
                                                             KjarniKjarniProgressCallbackFn progress_callback,
                                                             void *user_data,
                                                             const struct KjarniKjarniCancelToken *cancel_token,
                                                             uintptr_t *documents_added );

/**
 * Get information about an existing index.
 *
 * This is a static function that doesn't require an Indexer handle.
 *
 * # Arguments
 *
 * * `index_path` - Path to the index directory
 * * `out` - Pointer to receive index information
 *
 * # Returns
 *
 * `KjarniErrorCode::Ok` on success, error code otherwise.
 *
 * # Safety
 *
 * - All pointers must be valid
 * - Caller must free the returned `KjarniIndexInfo` with `kjarni_index_info_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_index_info( const char *index_path,
                                              struct KjarniKjarniIndexInfo *out );

/**
 * Delete an index.
 *
 * This permanently removes the index directory and all its contents.
 * This is a static function that doesn't require an Indexer handle.
 *
 * # Arguments
 *
 * * `index_path` - Path to the index directory to delete
 *
 * # Returns
 *
 * `KjarniErrorCode::Ok` on success, error code otherwise.
 *
 * # Safety
 *
 * - `index_path` must be a valid C string
 */
kjarni_ enum KjarniKjarniErrorCode kjarni_index_delete( const char *index_path );

/**
 * Get the embedding model name used by the indexer.
 *
 * # Arguments
 *
 * * `indexer` - Indexer handle
 *
 * # Returns
 *
 * Pointer to model name string, or NULL if indexer is NULL.
 * The returned pointer is valid until the next call to this function.
 *
 * # Safety
 *
 * - `indexer` must be a valid handle or NULL
 * - Returned string must not be modified or freed
 */
kjarni_ const char *kjarni_indexer_model_name( const struct KjarniKjarniIndexer *indexer );

/**
 * Get the embedding dimension used by the indexer.
 *
 * # Arguments
 *
 * * `indexer` - Indexer handle
 *
 * # Returns
 *
 * Embedding dimension, or 0 if indexer is NULL.
 */
kjarni_ uintptr_t kjarni_indexer_dimension( const struct KjarniKjarniIndexer *indexer );

/**
 * Get the chunk size configured for the indexer.
 *
 * # Arguments
 *
 * * `indexer` - Indexer handle
 *
 * # Returns
 *
 * Chunk size in characters, or 0 if indexer is NULL.
 */
kjarni_ uintptr_t kjarni_indexer_chunk_size( const struct KjarniKjarniIndexer *indexer );

/**
 * Free search results and all contained strings.
 *
 * # Safety
 *
 * Must only be called once per `KjarniSearchResults` returned from search functions.
 */
kjarni_ void kjarni_search_results_free( struct KjarniKjarniSearchResults results );

/**
 * Get default search options.
 *
 * Default values:
 * - mode: -1 (use searcher default, typically Hybrid)
 * - top_k: 0 (use searcher default, typically 10)
 * - use_reranker: -1 (auto - use if configured)
 * - threshold: 0.0 (no minimum score)
 * - All filters: NULL (no filtering)
 */
kjarni_ struct KjarniKjarniSearchOptions kjarni_search_options_default( void );

/**
 * Get default searcher configuration.
 *
 * Returns a configuration with sensible defaults:
 * - CPU device
 * - minilm-l6-v2 embedding model
 * - No reranker
 * - Hybrid search mode
 * - Top 10 results
 */
kjarni_ struct KjarniKjarniSearcherConfig kjarni_searcher_config_default( void );

/**
 * Create a new Searcher.
 *
 * # Arguments
 *
 * * `config` - Configuration options (NULL for defaults)
 * * `out` - Pointer to receive the created searcher handle
 *
 * # Returns
 *
 * `KjarniErrorCode::Ok` on success, error code otherwise.
 * On error, call `kjarni_last_error_message()` for details.
 *
 * # Safety
 *
 * - `out` must be a valid pointer
 * - The returned handle must be freed with `kjarni_searcher_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_searcher_new( const struct KjarniKjarniSearcherConfig *config,
                                                struct KjarniKjarniSearcher **out );

/**
 * Free a Searcher handle.
 *
 * # Safety
 *
 * - `searcher` must be a handle returned by `kjarni_searcher_new`
 * - Must not be called more than once per handle
 * - Handle must not be used after freeing
 */
kjarni_ void kjarni_searcher_free( struct KjarniKjarniSearcher *searcher );

/**
 * Search with default options.
 *
 * Equivalent to calling `kjarni_searcher_search_with_options` with default options.
 *
 * # Arguments
 *
 * * `searcher` - Searcher handle
 * * `index_path` - Path to the index directory
 * * `query` - Search query string
 * * `out` - Pointer to receive search results
 *
 * # Returns
 *
 * `KjarniErrorCode::Ok` on success, error code otherwise.
 *
 * # Safety
 *
 * - All pointers must be valid
 * - Results must be freed with `kjarni_search_results_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_searcher_search( struct KjarniKjarniSearcher *searcher,
                                                   const char *index_path,
                                                   const char *query,
                                                   struct KjarniKjarniSearchResults *out );

/**
 * Search with custom options.
 *
 * Performs a search query against the specified index with custom options
 * for search mode, result count, reranking, filtering, etc.
 *
 * # Arguments
 *
 * * `searcher` - Searcher handle
 * * `index_path` - Path to the index directory
 * * `query` - Search query string
 * * `options` - Search options (use `kjarni_search_options_default()` as base)
 * * `out` - Pointer to receive search results
 *
 * # Returns
 *
 * `KjarniErrorCode::Ok` on success, error code otherwise.
 *
 * # Safety
 *
 * - All pointers must be valid
 * - Results must be freed with `kjarni_search_results_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_searcher_search_with_options( struct KjarniKjarniSearcher *searcher,
                                                                const char *index_path,
                                                                const char *query,
                                                                const struct KjarniKjarniSearchOptions *options,
                                                                struct KjarniKjarniSearchResults *out );

/**
 * Static keyword search (BM25) - no embedder needed.
 *
 * This is a convenience function for pure keyword search that doesn't
 * require loading an embedding model. Useful for quick text matching.
 *
 * # Arguments
 *
 * * `index_path` - Path to the index directory
 * * `query` - Search query string
 * * `top_k` - Maximum number of results to return
 * * `out` - Pointer to receive search results
 *
 * # Returns
 *
 * `KjarniErrorCode::Ok` on success, error code otherwise.
 *
 * # Safety
 *
 * - All pointers must be valid
 * - Results must be freed with `kjarni_search_results_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_search_keywords( const char *index_path,
                                                   const char *query,
                                                   uintptr_t top_k,
                                                   struct KjarniKjarniSearchResults *out );

/**
 * Check if the searcher has a reranker configured.
 *
 * # Arguments
 *
 * * `searcher` - Searcher handle
 *
 * # Returns
 *
 * `true` if a reranker is configured, `false` otherwise.
 */
kjarni_ bool kjarni_searcher_has_reranker( const struct KjarniKjarniSearcher *searcher );

/**
 * Get the default search mode.
 *
 * # Arguments
 *
 * * `searcher` - Searcher handle
 *
 * # Returns
 *
 * The default search mode, or Hybrid if searcher is NULL.
 */
kjarni_
enum KjarniKjarniSearchMode kjarni_searcher_default_mode( const struct KjarniKjarniSearcher *searcher );

/**
 * Get the default number of results.
 *
 * # Arguments
 *
 * * `searcher` - Searcher handle
 *
 * # Returns
 *
 * The default top_k value, or 10 if searcher is NULL.
 */
kjarni_ uintptr_t kjarni_searcher_default_top_k( const struct KjarniKjarniSearcher *searcher );

/**
 * Get the embedding model name.
 *
 * # Arguments
 *
 * * `searcher` - Searcher handle
 *
 * # Returns
 *
 * Pointer to model name string, or NULL if searcher is NULL.
 * The returned pointer is valid until the next call to this function.
 *
 * # Safety
 *
 * - `searcher` must be a valid handle or NULL
 * - Returned string must not be modified or freed
 */
kjarni_ const char *kjarni_searcher_model_name( const struct KjarniKjarniSearcher *searcher );

/**
 * Get the reranker model name, if configured.
 *
 * # Arguments
 *
 * * `searcher` - Searcher handle
 *
 * # Returns
 *
 * Pointer to reranker model name string, or NULL if no reranker is configured.
 * The returned pointer is valid until the next call to this function.
 *
 * # Safety
 *
 * - `searcher` must be a valid handle or NULL
 * - Returned string must not be modified or freed
 */
kjarni_ const char *kjarni_searcher_reranker_model( const struct KjarniKjarniSearcher *searcher );

#endif  /* KJARNI_FFI_H */
