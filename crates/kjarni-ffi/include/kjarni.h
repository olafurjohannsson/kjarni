/*
 * Kjarni FFI - C bindings for Kjarni ML library
 * Auto-generated by cbindgen. Do not edit manually.
 */


#ifndef KJARNI_FFI_H
#define KJARNI_FFI_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

/**
 * Error codes returned by Kjarni FFI functions.
 */
typedef enum KjarniKjarniErrorCode {
  /**
   * Operation completed successfully
   */
  KJARNI_KJARNI_ERROR_CODE_OK = 0,
  /**
   * Null pointer passed to function
   */
  KJARNI_KJARNI_ERROR_CODE_NULL_POINTER = 1,
  /**
   * Invalid UTF-8 string
   */
  KJARNI_KJARNI_ERROR_CODE_INVALID_UTF8 = 2,
  /**
   * Model not found in registry
   */
  KJARNI_KJARNI_ERROR_CODE_MODEL_NOT_FOUND = 3,
  /**
   * Failed to load model
   */
  KJARNI_KJARNI_ERROR_CODE_LOAD_FAILED = 4,
  /**
   * Inference operation failed
   */
  KJARNI_KJARNI_ERROR_CODE_INFERENCE_FAILED = 5,
  /**
   * GPU not available
   */
  KJARNI_KJARNI_ERROR_CODE_GPU_UNAVAILABLE = 6,
  /**
   * Invalid configuration
   */
  KJARNI_KJARNI_ERROR_CODE_INVALID_CONFIG = 7,
  /**
   * Operation was cancelled
   */
  KJARNI_KJARNI_ERROR_CODE_CANCELLED = 8,
  /**
   * Operation timed out
   */
  KJARNI_KJARNI_ERROR_CODE_TIMEOUT = 9,
  /**
   * Stream has ended
   */
  KJARNI_KJARNI_ERROR_CODE_STREAM_ENDED = 10,
  /**
   * Unknown error
   */
  KJARNI_KJARNI_ERROR_CODE_UNKNOWN = 255,
} KjarniKjarniErrorCode;

/**
 * Device selection for inference.
 */
typedef enum KjarniKjarniDevice {
  /**
   * Use CPU for inference
   */
  KJARNI_KJARNI_DEVICE_CPU = 0,
  /**
   * Use GPU for inference
   */
  KJARNI_KJARNI_DEVICE_GPU = 1,
} KjarniKjarniDevice;

/**
 * Progress stage enum for FFI
 */
typedef enum KjarniKjarniProgressStage {
  KJARNI_KJARNI_PROGRESS_STAGE_SCANNING = 0,
  KJARNI_KJARNI_PROGRESS_STAGE_LOADING = 1,
  KJARNI_KJARNI_PROGRESS_STAGE_EMBEDDING = 2,
  KJARNI_KJARNI_PROGRESS_STAGE_WRITING = 3,
  KJARNI_KJARNI_PROGRESS_STAGE_COMMITTING = 4,
  KJARNI_KJARNI_PROGRESS_STAGE_SEARCHING = 5,
  KJARNI_KJARNI_PROGRESS_STAGE_RERANKING = 6,
} KjarniKjarniProgressStage;

/**
 * Search mode enum for FFI
 */
typedef enum KjarniKjarniSearchMode {
  KJARNI_KJARNI_SEARCH_MODE_KEYWORD = 0,
  KJARNI_KJARNI_SEARCH_MODE_SEMANTIC = 1,
  KJARNI_KJARNI_SEARCH_MODE_HYBRID = 2,
} KjarniKjarniSearchMode;

/**
 * Cancellation token handle
 */
typedef struct KjarniKjarniCancelToken KjarniKjarniCancelToken;

/**
 * Opaque handle to a Classifier.
 */
typedef struct KjarniKjarniClassifier KjarniKjarniClassifier;

/**
 * Opaque handle to an Embedder instance.
 */
typedef struct KjarniKjarniEmbedder KjarniKjarniEmbedder;

/**
 * Opaque handle to an Indexer
 */
typedef struct KjarniKjarniIndexer KjarniKjarniIndexer;

/**
 * Opaque handle to a Reranker
 */
typedef struct KjarniKjarniReranker KjarniKjarniReranker;

/**
 * Opaque handle to a Searcher
 */
typedef struct KjarniKjarniSearcher KjarniKjarniSearcher;

/**
 * Float array returned by FFI functions. Caller must free with kjarni_float_array_free.
 */
typedef struct KjarniKjarniFloatArray {
  float *data;
  uintptr_t len;
} KjarniKjarniFloatArray;

/**
 * 2D float array for batch results. Caller must free with kjarni_float_2d_array_free.
 */
typedef struct KjarniKjarniFloat2DArray {
  float *data;
  uintptr_t rows;
  uintptr_t cols;
} KjarniKjarniFloat2DArray;

/**
 * String array. Caller must free with kjarni_string_array_free.
 */
typedef struct KjarniKjarniStringArray {
  char **strings;
  uintptr_t len;
} KjarniKjarniStringArray;

/**
 * Configuration for creating an Embedder.
 */
typedef struct KjarniKjarniEmbedderConfig {
  /**
   * Device to use (CPU or GPU)
   */
  enum KjarniKjarniDevice device;
  /**
   * Cache directory for models (NULL = default)
   */
  const char *cache_dir;
  /**
   * Model name from registry (NULL = "minilm-l6-v2")
   */
  const char *model_name;
  /**
   * Path to local model (NULL = use registry)
   */
  const char *model_path;
  /**
   * Whether to L2-normalize embeddings (1 = yes, 0 = no)
   */
  int32_t normalize;
  /**
   * Suppress progress output (1 = quiet, 0 = verbose)
   */
  int32_t quiet;
} KjarniKjarniEmbedderConfig;

/**
 * Single classification result (label + score).
 */
typedef struct KjarniKjarniClassResult {
  /**
   * Label name (must be freed with kjarni_string_free)
   */
  char *label;
  /**
   * Confidence score
   */
  float score;
} KjarniKjarniClassResult;

/**
 * Array of classification results.
 */
typedef struct KjarniKjarniClassResults {
  /**
   * Array of results
   */
  struct KjarniKjarniClassResult *results;
  /**
   * Number of results
   */
  uintptr_t len;
} KjarniKjarniClassResults;

/**
 * Configuration for creating a Classifier.
 */
typedef struct KjarniKjarniClassifierConfig {
  /**
   * Device to use
   */
  enum KjarniKjarniDevice device;
  /**
   * Cache directory (NULL = default)
   */
  const char *cache_dir;
  /**
   * Model name (NULL = default)
   */
  const char *model_name;
  /**
   * Model path (NULL = use registry)
   */
  const char *model_path;
  /**
   * Custom labels (NULL = use model labels)
   */
  const char *const *labels;
  /**
   * Number of custom labels
   */
  uintptr_t num_labels;
  /**
   * Multi-label mode (1 = multi-label, 0 = single-label)
   */
  int32_t multi_label;
  /**
   * Suppress output
   */
  int32_t quiet;
} KjarniKjarniClassifierConfig;

/**
 * Single rerank result
 */
typedef struct KjarniKjarniRerankResult {
  uintptr_t index;
  float score;
} KjarniKjarniRerankResult;

/**
 * Array of rerank results
 */
typedef struct KjarniKjarniRerankResults {
  struct KjarniKjarniRerankResult *results;
  uintptr_t len;
} KjarniKjarniRerankResults;

/**
 * Configuration for Reranker
 */
typedef struct KjarniKjarniRerankerConfig {
  enum KjarniKjarniDevice device;
  const char *cache_dir;
  const char *model_name;
  const char *model_path;
  int32_t quiet;
} KjarniKjarniRerankerConfig;

/**
 * Information about an existing index
 */
typedef struct KjarniKjarniIndexInfo {
  char *path;
  uintptr_t document_count;
  uintptr_t segment_count;
  uintptr_t dimension;
  uint64_t size_bytes;
  char *embedding_model;
} KjarniKjarniIndexInfo;

/**
 * Configuration for creating an Indexer
 */
typedef struct KjarniKjarniIndexerConfig {
  enum KjarniKjarniDevice device;
  const char *cache_dir;
  const char *model_name;
  uintptr_t chunk_size;
  uintptr_t chunk_overlap;
  uintptr_t batch_size;
  /**
   * Comma-separated list of extensions (NULL = use defaults)
   */
  const char *extensions;
  /**
   * Comma-separated list of exclude patterns
   */
  const char *exclude_patterns;
  int32_t recursive;
  int32_t include_hidden;
  uintptr_t max_file_size;
  int32_t quiet;
} KjarniKjarniIndexerConfig;

/**
 * Statistics returned after indexing
 */
typedef struct KjarniKjarniIndexStats {
  uintptr_t documents_indexed;
  uintptr_t chunks_created;
  uintptr_t dimension;
  uint64_t size_bytes;
  uintptr_t files_processed;
  uintptr_t files_skipped;
  uint64_t elapsed_ms;
} KjarniKjarniIndexStats;

/**
 * Progress data passed to callbacks
 */
typedef struct KjarniKjarniProgress {
  enum KjarniKjarniProgressStage stage;
  uintptr_t current;
  uintptr_t total;
  /**
   * Message string (may be NULL)
   */
  const char *message;
} KjarniKjarniProgress;

/**
 * Progress callback function pointer type
 *
 * Arguments:
 * - progress: Progress data
 * - user_data: User-provided context pointer
 */
typedef void (*KjarniKjarniProgressCallbackFn)(struct KjarniKjarniProgress progress, void *user_data);

/**
 * Single search result
 */
typedef struct KjarniKjarniSearchResult {
  float score;
  uintptr_t document_id;
  char *text;
  char *metadata_json;
} KjarniKjarniSearchResult;

/**
 * Array of search results
 */
typedef struct KjarniKjarniSearchResults {
  struct KjarniKjarniSearchResult *results;
  uintptr_t len;
} KjarniKjarniSearchResults;

/**
 * Search options
 */
typedef struct KjarniKjarniSearchOptions {
  /**
   * Search mode (-1 = use default)
   */
  int32_t mode;
  /**
   * Number of results (0 = use default)
   */
  uintptr_t top_k;
  /**
   * Use reranker (-1 = auto, 0 = no, 1 = yes)
   */
  int32_t use_reranker;
  /**
   * Minimum score threshold (0 = no threshold)
   */
  float threshold;
  /**
   * Source pattern filter (NULL = no filter)
   */
  const char *source_pattern;
  /**
   * Required metadata key (NULL = no filter)
   */
  const char *filter_key;
  /**
   * Required metadata value (NULL = no filter)
   */
  const char *filter_value;
} KjarniKjarniSearchOptions;

/**
 * Searcher configuration
 */
typedef struct KjarniKjarniSearcherConfig {
  enum KjarniKjarniDevice device;
  const char *cache_dir;
  const char *model_name;
  const char *rerank_model;
  enum KjarniKjarniSearchMode default_mode;
  uintptr_t default_top_k;
  int32_t quiet;
} KjarniKjarniSearcherConfig;

/**
 * Initialize the Kjarni runtime. Optional - auto-initialized on first use.
 */
kjarni_ enum KjarniKjarniErrorCode kjarni_init(void);

/**
 * Shutdown and cleanup. Call before process exit.
 */
kjarni_ void kjarni_shutdown(void);

/**
 * Get the library version string.
 */
kjarni_ const char *kjarni_version(void);

/**
 * Free a float array allocated by Kjarni.
 */
kjarni_ void kjarni_float_array_free(struct KjarniKjarniFloatArray arr);

/**
 * Free a 2D float array allocated by Kjarni.
 */
kjarni_ void kjarni_float_2d_array_free(struct KjarniKjarniFloat2DArray arr);

/**
 * Free a string allocated by Kjarni.
 */
kjarni_ void kjarni_string_free(char *s);

/**
 * Free a string array allocated by Kjarni.
 */
kjarni_ void kjarni_string_array_free(struct KjarniKjarniStringArray arr);

/**
 * Create a new cancellation token
 */
kjarni_ struct KjarniKjarniCancelToken *kjarni_cancel_token_new(void);

/**
 * Cancel the operation associated with this token
 */
kjarni_ void kjarni_cancel_token_cancel(struct KjarniKjarniCancelToken *token);

/**
 * Check if token is cancelled
 */
kjarni_ bool kjarni_cancel_token_is_cancelled(const struct KjarniKjarniCancelToken *token);

/**
 * Reset the cancellation token
 */
kjarni_ void kjarni_cancel_token_reset(struct KjarniKjarniCancelToken *token);

/**
 * Free a cancellation token
 */
kjarni_ void kjarni_cancel_token_free(struct KjarniKjarniCancelToken *token);

kjarni_ const char *kjarni_error_code_to_string(enum KjarniKjarniErrorCode err);

/**
 * Get the name of an error code as a C string.
 */
kjarni_ const char *kjarni_error_name(enum KjarniKjarniErrorCode err);

/**
 * Get the last error message. Returns NULL if no error.
 */
kjarni_ const char *kjarni_last_error_message(void);

/**
 * Clear the last error.
 */
kjarni_ void kjarni_clear_error(void);

/**
 * Get default embedder configuration.
 */
kjarni_ struct KjarniKjarniEmbedderConfig kjarni_embedder_config_default(void);

/**
 * Create a new Embedder.
 *
 * # Safety
 * - `config` must be valid or NULL (uses defaults)
 * - `out` must be a valid pointer
 * - The returned handle must be freed with `kjarni_embedder_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_embedder_new(const struct KjarniKjarniEmbedderConfig *config,
                                               struct KjarniKjarniEmbedder **out);

/**
 * Free an Embedder instance.
 *
 * # Safety
 * - `embedder` must be a valid handle or NULL
 * - The handle must not be used after this call
 */
kjarni_ void kjarni_embedder_free(struct KjarniKjarniEmbedder *embedder);

/**
 * Encode a single text to an embedding vector.
 *
 * # Safety
 * - `embedder` must be a valid handle
 * - `text` must be a valid null-terminated UTF-8 string
 * - `out` must be a valid pointer
 * - The returned array must be freed with `kjarni_float_array_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_embedder_encode(struct KjarniKjarniEmbedder *embedder,
                                                  const char *text,
                                                  struct KjarniKjarniFloatArray *out);

/**
 * Encode multiple texts to embedding vectors.
 *
 * # Safety
 * - `embedder` must be a valid handle
 * - `texts` must be an array of `num_texts` valid null-terminated UTF-8 strings
 * - `out` must be a valid pointer
 * - The returned array must be freed with `kjarni_float_2d_array_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_embedder_encode_batch(struct KjarniKjarniEmbedder *embedder,
                                                        const char *const *texts,
                                                        uintptr_t num_texts,
                                                        struct KjarniKjarniFloat2DArray *out);

/**
 * Compute cosine similarity between two texts.
 *
 * # Safety
 * - `embedder` must be a valid handle
 * - `text1` and `text2` must be valid null-terminated UTF-8 strings
 * - `out` must be a valid pointer
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_embedder_similarity(struct KjarniKjarniEmbedder *embedder,
                                                      const char *text1,
                                                      const char *text2,
                                                      float *out);

/**
 * Get the embedding dimension.
 *
 * # Safety
 * - `embedder` must be a valid handle
 */
kjarni_ uintptr_t kjarni_embedder_dim(const struct KjarniKjarniEmbedder *embedder);

/**
 * Free classification results.
 */
kjarni_ void kjarni_class_results_free(struct KjarniKjarniClassResults results);

/**
 * Get default classifier configuration.
 */
kjarni_ struct KjarniKjarniClassifierConfig kjarni_classifier_config_default(void);

/**
 * Create a new Classifier.
 *
 * # Safety
 * - `config` must be valid or NULL
 * - `out` must be a valid pointer
 * - The returned handle must be freed with `kjarni_classifier_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_classifier_new(const struct KjarniKjarniClassifierConfig *config,
                                                 struct KjarniKjarniClassifier **out);

/**
 * Free a Classifier.
 */
kjarni_ void kjarni_classifier_free(struct KjarniKjarniClassifier *classifier);

/**
 * Classify a single text.
 *
 * # Safety
 * - `classifier` must be valid
 * - `text` must be valid UTF-8
 * - `out` must be valid
 * - Results must be freed with `kjarni_class_results_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_classifier_classify(struct KjarniKjarniClassifier *classifier,
                                                      const char *text,
                                                      struct KjarniKjarniClassResults *out);

/**
 * Get the classifier's labels.
 *
 * # Safety
 * - `classifier` must be valid
 * - `out` must be valid
 * - Results must be freed with `kjarni_string_array_free`
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_classifier_labels(const struct KjarniKjarniClassifier *classifier,
                                                    struct KjarniKjarniStringArray *out);

/**
 * Get number of labels.
 */
kjarni_ uintptr_t kjarni_classifier_num_labels(const struct KjarniKjarniClassifier *classifier);

/**
 * Free rerank results
 */
kjarni_ void kjarni_rerank_results_free(struct KjarniKjarniRerankResults results);

/**
 * Get default reranker configuration
 */
kjarni_ struct KjarniKjarniRerankerConfig kjarni_reranker_config_default(void);

/**
 * Create a new Reranker
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_reranker_new(const struct KjarniKjarniRerankerConfig *config,
                                               struct KjarniKjarniReranker **out);

/**
 * Free a Reranker
 */
kjarni_ void kjarni_reranker_free(struct KjarniKjarniReranker *reranker);

/**
 * Score a single query-document pair
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_reranker_score(struct KjarniKjarniReranker *reranker,
                                                 const char *query,
                                                 const char *document,
                                                 float *out);

/**
 * Rerank documents by relevance to query
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_reranker_rerank(struct KjarniKjarniReranker *reranker,
                                                  const char *query,
                                                  const char *const *documents,
                                                  uintptr_t num_docs,
                                                  struct KjarniKjarniRerankResults *out);

/**
 * Rerank and return top-k results
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_reranker_rerank_top_k(struct KjarniKjarniReranker *reranker,
                                                        const char *query,
                                                        const char *const *documents,
                                                        uintptr_t num_docs,
                                                        uintptr_t top_k,
                                                        struct KjarniKjarniRerankResults *out);

/**
 * Free index info strings
 */
kjarni_ void kjarni_index_info_free(struct KjarniKjarniIndexInfo info);

/**
 * Get default indexer configuration
 */
kjarni_ struct KjarniKjarniIndexerConfig kjarni_indexer_config_default(void);

/**
 * Create a new Indexer
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_indexer_new(const struct KjarniKjarniIndexerConfig *config,
                                              struct KjarniKjarniIndexer **out);

/**
 * Free an Indexer
 */
kjarni_ void kjarni_indexer_free(struct KjarniKjarniIndexer *indexer);

/**
 * Create a new index (simple version, outputs to stderr)
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_indexer_create(struct KjarniKjarniIndexer *indexer,
                                                 const char *index_path,
                                                 const char *const *inputs,
                                                 uintptr_t num_inputs,
                                                 int32_t force,
                                                 struct KjarniKjarniIndexStats *out);

/**
 * Create a new index with progress callback
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_indexer_create_with_callback(struct KjarniKjarniIndexer *indexer,
                                                               const char *index_path,
                                                               const char *const *inputs,
                                                               uintptr_t num_inputs,
                                                               int32_t force,
                                                               KjarniKjarniProgressCallbackFn progress_callback,
                                                               void *user_data,
                                                               const struct KjarniKjarniCancelToken *cancel_token,
                                                               struct KjarniKjarniIndexStats *out);

/**
 * Add documents to existing index
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_indexer_add(struct KjarniKjarniIndexer *indexer,
                                              const char *index_path,
                                              const char *const *inputs,
                                              uintptr_t num_inputs,
                                              uintptr_t *documents_added);

/**
 * Add documents with progress callback
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_indexer_add_with_callback(struct KjarniKjarniIndexer *indexer,
                                                            const char *index_path,
                                                            const char *const *inputs,
                                                            uintptr_t num_inputs,
                                                            KjarniKjarniProgressCallbackFn progress_callback,
                                                            void *user_data,
                                                            const struct KjarniKjarniCancelToken *cancel_token,
                                                            uintptr_t *documents_added);

/**
 * Get index information (static - no indexer needed)
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_index_info(const char *index_path,
                                             struct KjarniKjarniIndexInfo *out);

/**
 * Delete an index
 */
kjarni_ enum KjarniKjarniErrorCode kjarni_index_delete(const char *index_path);

kjarni_ const char *kjarni_indexer_model_name(const struct KjarniKjarniIndexer *indexer);

kjarni_ uintptr_t kjarni_indexer_dimension(const struct KjarniKjarniIndexer *indexer);

kjarni_ uintptr_t kjarni_indexer_chunk_size(const struct KjarniKjarniIndexer *indexer);

/**
 * Free search results
 */
kjarni_ void kjarni_search_results_free(struct KjarniKjarniSearchResults results);

/**
 * Get default search options
 */
kjarni_ struct KjarniKjarniSearchOptions kjarni_search_options_default(void);

/**
 * Get default searcher configuration
 */
kjarni_ struct KjarniKjarniSearcherConfig kjarni_searcher_config_default(void);

/**
 * Create a new Searcher
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_searcher_new(const struct KjarniKjarniSearcherConfig *config,
                                               struct KjarniKjarniSearcher **out);

/**
 * Free a Searcher
 */
kjarni_ void kjarni_searcher_free(struct KjarniKjarniSearcher *searcher);

/**
 * Search with default options
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_searcher_search(struct KjarniKjarniSearcher *searcher,
                                                  const char *index_path,
                                                  const char *query,
                                                  struct KjarniKjarniSearchResults *out);

/**
 * Search with custom options
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_searcher_search_with_options(struct KjarniKjarniSearcher *searcher,
                                                               const char *index_path,
                                                               const char *query,
                                                               const struct KjarniKjarniSearchOptions *options,
                                                               struct KjarniKjarniSearchResults *out);

/**
 * Static keyword search (no embedder needed)
 */
kjarni_
enum KjarniKjarniErrorCode kjarni_search_keywords(const char *index_path,
                                                  const char *query,
                                                  uintptr_t top_k,
                                                  struct KjarniKjarniSearchResults *out);

kjarni_ bool kjarni_searcher_has_reranker(const struct KjarniKjarniSearcher *searcher);

kjarni_
enum KjarniKjarniSearchMode kjarni_searcher_default_mode(const struct KjarniKjarniSearcher *searcher);

kjarni_ uintptr_t kjarni_searcher_default_top_k(const struct KjarniKjarniSearcher *searcher);

#endif  /* KJARNI_FFI_H */
